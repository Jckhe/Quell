const { visit, BREAK } = require('graphql/language/visitor');

/**
 * parseAST traverses the abstract syntax tree depth-first to create a template for future operations, such as
 * request data from the cache, creating a modified query string for additional information needed, and joining cache and database responses
 * @param {Object} AST - an abstract syntax tree generated by gql library that we will traverse to build our prototype
 * @param {Object} options - a field for user-supplied options, not fully integrated
 * RETURNS prototype, operationType, and frags object
*/

const parseAST = (AST, options = { userDefinedID: null }) => {
    // initialize prototype as empty object
    // information from AST is distilled into the prototype for easy access during caching, rebuilding query strings, etc.
    const proto = {};
    const frags = {};

    // target Object points to prototype when iterating through Field, and will point to frags when iterating through Fragment Definition
    let targetObj;

    // will be query, mutation, subscription, or unQuellable
    let operationType = '';

    // initialize stack to keep track of depth first parsing path
    const stack = [];

    // tracks arguments, aliases, etc. for specific fields
    // eventually merged with prototype object
    const fieldArgs = {};

    // extract userDefinedID from options object, if provided
    const userDefinedID = options.userDefinedID;

    /**
     * visit is a utility provided in the graphql-JS library. It performs a
     * depth-first traversal of the abstract syntax tree, invoking a callback
     * when each SelectionSet node is entered. That function builds the prototype.
     * Invokes a callback when entering and leaving Field node to keep track of nodes with stack
     *
     * Find documentation at:
     * https://graphql.org/graphql-js/language/#visit
     */
    visit(AST, {
      enter(node) {
        //cannot cache directives, return as unquellable
        if (node.directives) {
          if (node.directives.length > 0) {
            operationType = 'unQuellable';
            return BREAK;
          }
        }
      },
      OperationDefinition(node) {
        targetObj = proto;
        //cannot cache subscriptions, return as unquellable
        operationType = node.operation;
        if (node.operation === 'subscription') {
          operationType = 'unQuellable';
          return BREAK;
        }
      },
      // set-up for fragment definition traversal
      FragmentDefinition: {
        enter(node) {
          // update stack for path tracking
          stack.push(node.name.value);
          // point the targetObj that we update to the frags object while inside the loop
          targetObj = frags;

          // extract base-level fields in the fragment into frags object
          const fragName = node.name.value;
          targetObj[fragName] = {};
          for (let i = 0; i < node.selectionSet.selections.length; i++) {
            targetObj[fragName][
              node.selectionSet.selections[i].name.value
            ] = true;
          }
        },
        leave() {
          stack.pop();
        },
      },
      Field: {
        enter(node) {
          // return introspection queries as unQuellable to not cache them
          // "__keyname" syntax is later used for Quell's field-specific options, though this does not create collision with introspection
          if (node.name.value.includes('__')) {
            operationType = 'unQuellable';
            return BREAK;
          }

          // populates argsObj from current node's arguments
          // generates uniqueID
          const argsObj = {};

          // auxillary object for storing arguments, aliases, field-specific options, and more
          // query-wide options should be handled on Quell's options object
          const auxObj = {
            __id: null,
          };
          node.arguments.forEach((arg) => {
            const key = arg.name.value;
            // pass variables through
            if (arg.value.kind === 'Variable' && operationType === 'query') {
              operationType = 'unQuellable';
              return BREAK;
            }

            // assign args to argsObj, skipping field-specific options ('__') provided as arguments
            if (!key.includes('__')) {
              argsObj[key] = arg.value.value;
            }

            // identify uniqueID from args, options
            // assigns ID as userDefinedID if one is supplied on options object
            // note: do not use key.includes('id') to avoid assigning fields such as "idea" or "idiom" as uniqueID
            if (userDefinedID ? key === userDefinedID : false) {
              auxObj.__id = arg.value.value;
            } else if (
              key === 'id' ||
              key === '_id' ||
              key === 'ID' ||
              key === 'Id'
            ) {
              auxObj.__id = arg.value.value;
            }

            // handle custom field-specific options passed in as arguments (ie __customCacheTime)
            // arguments parsed in this way should not pass from client to server
            // downstream support not fully integrated
            if (key.includes('__')) {
              auxObj[key] = arg.value.value;
            }
          });

          // gather auxillary data such as aliases, arguments, query type, and more to append to the prototype for future reference

          const fieldType = node.alias ? node.alias.value : node.name.value;

          // query type is forced lower case to ensure consistent caching
          auxObj.__type = node.name.value.toLowerCase();

          auxObj.__alias = node.alias ? node.alias.value : null;

          auxObj.__args = Object.keys(argsObj).length > 0 ? argsObj : null;

          // adds auxObj fields to prototype, allowing future access to type, alias, args, etc.
          fieldArgs[fieldType] = {
            ...fieldArgs[fieldType],
            ...auxObj,
          };

          // add value to stacks to keep track of depth-first parsing path
          stack.push(fieldType);
        },
        leave() {
          // pop stacks to keep track of depth-first parsing path
          stack.pop();
        },
      },
      SelectionSet: {
        // selection sets contain all of the sub-fields
        // iterate through the sub-fields to construct fieldsObject
        enter(node, key, parent, path, ancestors) {
          selectionSetDepth++;

          /* Exclude SelectionSet nodes whose parents' are not of the kind
           * 'Field' to exclude nodes that do not contain information about
           *  queried fields.
           */
          if (parent.kind === 'Field') {
            const fieldsValues = {};
            for (let field of node.selections) {
              // sets any fields values to true, unless it is a nested object (ie has selectionSet)
              if (!field.selectionSet) fieldsValues[field.name.value] = true;
            }

            // if ID was not included on the request then the query will not be included in the cache, but the request will be processed
            if (
              !fieldsValues.hasOwnProperty('id') &&
              !fieldsValues.hasOwnProperty('_id') &&
              !fieldsValues.hasOwnProperty('ID') &&
              !fieldsValues.hasOwnProperty('Id')
            ) {
              operationType = 'noID';
              return BREAK;
            }

            // place current fieldArgs object onto fieldsObject so it gets passed along to prototype
            // fieldArgs contains arguments, aliases, etc.
            const fieldsObject = {
              ...fieldsValues,
              ...fieldArgs[stack[stack.length - 1]],
            };

            // loop through stack to get correct path in proto for temp object;

            stack.reduce((prev, curr, index) => {
              return index + 1 === stack.length // if last item in path
                ? (prev[curr] = { ...fieldsObject }) //set value
                : (prev[curr] = prev[curr]); // otherwise, if index exists, keep value
            }, targetObj);
          }
        },
        leave() {
          // tracking depth of selection set
          selectionSetDepth--;
        },
      },
    });
  return { proto, operationType, frags };
};

module.exports = parseAST;